[{"categories":null,"content":" 关于我 | About Me ","date":"2019-08-02","objectID":"/about/:0:0","series":null,"tags":null,"title":"About Aphasia","uri":"/about/#"},{"categories":null,"content":"简介📝 我赞同一个事实：Life becomes a lot more fun when you know that it is meaningless. Everyone is going to die, so anyone who enjoys their life has just had an extra treat. It is just a big bonus. 我的一些信息： A university student Learning: Python Go Hobby: 划水 Motto: Harder，luckier ","date":"2019-08-02","objectID":"/about/:1:0","series":null,"tags":null,"title":"About Aphasia","uri":"/about/#简介📝"},{"categories":["Go"],"content":"装饰器作为Python重要部分之一，是必须掌握的知识点。学会了就能马上装起来😄 ","date":"0001-01-01","objectID":"/posts/decorator/:0:0","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#"},{"categories":["Go"],"content":"Python装饰器 我们先从字面上来理解一下。装饰器就是拿来装饰物品的，就像你在搭配自己的穿衣一样，可以加一顶帽子、一副墨镜等等，而完全不用对你的脑袋和眼睛作一些修改~ ","date":"0001-01-01","objectID":"/posts/decorator/:0:0","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#python装饰器"},{"categories":["Go"],"content":"前置知识 Python程序执行顺序：从上向下执行！ def demo(): print(\"这是demo函数\") 几个概念，可以帮助我们理解后面的装饰器运行机制. def outer(func): def inner(): print(\"我是内层函数！\") return inner def foo(): print(\"我是原始函数！\") outer(foo) outer(foo()) 概念 object 函数名 outer、inner、demo 函数体 - 返回值 return ～ 函数内存地址 id() 函数名() 调用函数 函数名作为参数 outer(foo) 函数名()作为参数 返回值作为参数 返回函数名 return inner 返回函数名() 返回返回值 ","date":"0001-01-01","objectID":"/posts/decorator/:1:0","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#前置知识"},{"categories":["Go"],"content":"Question 假定我们每一个人都负责一个模块 def demo1(): print(\"这是瑶瑶负责的部分！\") def demo2(): print(\"这是光光负责的部分！\") def demo3(): print(\"这是坤坤负责的部分！\") # 分别做自己负责的那一部分 demo1() demo2() demo3() 为每一个负责的模块儿进行合格性检测？ ","date":"0001-01-01","objectID":"/posts/decorator/:2:0","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#question"},{"categories":["Go"],"content":"演化 ","date":"0001-01-01","objectID":"/posts/decorator/:3:0","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#演化"},{"categories":["Go"],"content":"装饰器是如何运行的(运行机制)？ def outer(func): def run(): print(\"合格检测已通过!\") result = func() print(\"执行成功!\") return result return run @outer def foo(): print(\"光光在睡觉！\") foo() def outer(func): print(\"合格检测已通过!\") result = func() print(\"执行成功!\") return result @outer def foo(): print(\"坤坤负责的部分!\") 程序如何运行？ 程序开始，读到outer(func)函数，函数体写入内存 程序进行到@outer，执行@后的函数。这里@是Python的语法糖，程序读到这里就知道应该运行后面的outer函数 程序到了outer(func)函数，被装饰的函数foo作为参数传递给了func。func=foo，@outer=outer(foo)，传递的是foo函数体，不是执行foo后的返回值 程序进入outer内部，将run函数定义块读入内存 return run，返回函数名run，且函数名run被赋值给f1这个被装饰的函数，即f1 = run 再次调用foo函数时候，执行的就是不再是foo函数的代码 def foo(func): print(\"foo\") func() return func @foo def func_a(): print(\"func_a\") import time def timeit(func): def inner(): start = time.time() func() end = time.time() print(\"duration time : %ds\" % int(end - start)) return inner def hello(): time.sleep(1) print(\"Hello\") hello = timeit(hello) hello() @timeit def hello(): time.sleep(1) print(\"Hello\") hello() print(hello.__name__) import time from functools import wraps def timeit(func): @wraps(func) def inner(): start = time.time() func() end = time.time() print(\"duration time : %ds\" % int(end - start)) return inner @timeit def hello(): time.sleep(1) print(\"hello\") print(hello.__name__) import time from functools import wraps def timeit(func): @wraps(func) def inner(name): start = time.time() func(name) end = time.time() print(\"duration time : %ds\" % int(end - start)) return inner @timeit def hello(name): time.sleep(1) print(\"Hello %s\" % name) hello(\"Docuration\") import time from functools import wraps def timeit(func): @wraps(func) def inner(*args, **kwargs): start = time.time() func(*args, **kwargs) end = time.time() print(\"duration time : %ds\" % int(end - start)) return inner @timeit def hello(name): time.sleep(1) print(\"hello %s\" % name) @timeit def say(name, age): print(\"hello %s%s\" % (name, age)) @timeit def say2(name, age = 20): print(\"hello %s%s\" % (name, age)) hello(\"小王子\") say(\"张5\", 20) say2(\"李3\") import time from functools import wraps def timeit(profix): def decoration(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() func(*args, **kwargs) end = time.time() print(\"%s: duration time : %ds\" % (profix, int(end - start))) return wrapper return decoration @timeit(\"profix1\") def hello(name): time.sleep(1) print(\"hello %s\" % name) hello(\"Chromium\") import time from functools import wraps class Timeit(object): \"\"\" 用类实现装饰器 \"\"\" def __init__(self, profix): self.profix = profix def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() func(*args, **kwargs) end = time.time() print(\"%s:duration time :%ds\" % (self.profix, int(end - start))) return wrapper @Timeit(\"profix\") def hello(): time.sleep(1) print(\"Hello\") hello() ","date":"0001-01-01","objectID":"/posts/decorator/:3:1","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#装饰器是如何运行的运行机制"},{"categories":["Go"],"content":"装饰器是如何运行的(运行机制)？ def outer(func): def run(): print(\"合格检测已通过!\") result = func() print(\"执行成功!\") return result return run @outer def foo(): print(\"光光在睡觉！\") foo() def outer(func): print(\"合格检测已通过!\") result = func() print(\"执行成功!\") return result @outer def foo(): print(\"坤坤负责的部分!\") 程序如何运行？ 程序开始，读到outer(func)函数，函数体写入内存 程序进行到@outer，执行@后的函数。这里@是Python的语法糖，程序读到这里就知道应该运行后面的outer函数 程序到了outer(func)函数，被装饰的函数foo作为参数传递给了func。func=foo，@outer=outer(foo)，传递的是foo函数体，不是执行foo后的返回值 程序进入outer内部，将run函数定义块读入内存 return run，返回函数名run，且函数名run被赋值给f1这个被装饰的函数，即f1 = run 再次调用foo函数时候，执行的就是不再是foo函数的代码 def foo(func): print(\"foo\") func() return func @foo def func_a(): print(\"func_a\") import time def timeit(func): def inner(): start = time.time() func() end = time.time() print(\"duration time : %ds\" % int(end - start)) return inner def hello(): time.sleep(1) print(\"Hello\") hello = timeit(hello) hello() @timeit def hello(): time.sleep(1) print(\"Hello\") hello() print(hello.__name__) import time from functools import wraps def timeit(func): @wraps(func) def inner(): start = time.time() func() end = time.time() print(\"duration time : %ds\" % int(end - start)) return inner @timeit def hello(): time.sleep(1) print(\"hello\") print(hello.__name__) import time from functools import wraps def timeit(func): @wraps(func) def inner(name): start = time.time() func(name) end = time.time() print(\"duration time : %ds\" % int(end - start)) return inner @timeit def hello(name): time.sleep(1) print(\"Hello %s\" % name) hello(\"Docuration\") import time from functools import wraps def timeit(func): @wraps(func) def inner(*args, **kwargs): start = time.time() func(*args, **kwargs) end = time.time() print(\"duration time : %ds\" % int(end - start)) return inner @timeit def hello(name): time.sleep(1) print(\"hello %s\" % name) @timeit def say(name, age): print(\"hello %s%s\" % (name, age)) @timeit def say2(name, age = 20): print(\"hello %s%s\" % (name, age)) hello(\"小王子\") say(\"张5\", 20) say2(\"李3\") import time from functools import wraps def timeit(profix): def decoration(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() func(*args, **kwargs) end = time.time() print(\"%s: duration time : %ds\" % (profix, int(end - start))) return wrapper return decoration @timeit(\"profix1\") def hello(name): time.sleep(1) print(\"hello %s\" % name) hello(\"Chromium\") import time from functools import wraps class Timeit(object): \"\"\" 用类实现装饰器 \"\"\" def __init__(self, profix): self.profix = profix def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() func(*args, **kwargs) end = time.time() print(\"%s:duration time :%ds\" % (self.profix, int(end - start))) return wrapper @Timeit(\"profix\") def hello(): time.sleep(1) print(\"Hello\") hello() ","date":"0001-01-01","objectID":"/posts/decorator/:3:1","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#程序如何运行"},{"categories":["Go"],"content":"装饰器使用场景 ","date":"0001-01-01","objectID":"/posts/decorator/:4:0","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#装饰器使用场景"},{"categories":["Go"],"content":"记录调用日志 import logging from functools import wraps def logging(func): @wraps(func) def wrapper(*args, **kwargs): logging.info(\"call method: %s%s%s\", func.func_name, args, kwargs) return func(*args, *kwargs) return wrapper ","date":"0001-01-01","objectID":"/posts/decorator/:4:1","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#记录调用日志"},{"categories":["Go"],"content":"记录方法执行耗时 from functools import wraps def timeit(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) duration = int(time.time() - start) print(\"method: %s, time: %s\" % (func.func_name, duration)) return result return wrapper ","date":"0001-01-01","objectID":"/posts/decorator/:4:2","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#记录方法执行耗时"},{"categories":["Go"],"content":"记录方法执行次数 from functools import wraps def counter(func): @wraps(func) def wrapper(*args, **kwargs): wrapper.count = wrapper.count + 1 print(\"method: %s, count: %s\" % (func.func_name, wrapper.count)) return func(*args, **kwargs) wrapper.count = 0 return wrapper ","date":"0001-01-01","objectID":"/posts/decorator/:4:3","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#记录方法执行次数"},{"categories":["Go"],"content":"本度缓存 from functools import wraps def localcache(func): cache = {} miss = object() @wraps(func) def wrapper(*args): result = cached.get(args, miss) if result is miss: result = func(*args) cached[args] = result return result return wrapper ","date":"0001-01-01","objectID":"/posts/decorator/:4:4","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#本度缓存"},{"categories":["Go"],"content":"路由映射 class Router(object): def __init__(self): self.url_map = {} def register(self, url): def wrapper(func): self.url_map[url] = func return wrapper def call(self, url): func = self.url_map.get(url) if not func: raise ValueError(\"No url function: %s\", url) return func() router = Router() @router.register(\"/page1\") def page1(): return \"This is page 1\" @router.register(\"/page2\") def page2(): return \"This is page 2\" print(router.call(\"/page1\")) print(router.call(\"/page2\")) ","date":"0001-01-01","objectID":"/posts/decorator/:4:5","series":null,"tags":["Python"],"title":"用装饰器装起来～","uri":"/posts/decorator/#路由映射"}]